## Roadmap

### MVP Scope

The Minimum Viable Product for YAGE should deliver a **lean but functional engine core** demonstrating the unique philosophy (Rust-first, FP-friendly, configurable, source-driven). MVP features include:

* **Engine Core Kernel:** Lifecycle management (init, update, shutdown).
* **Basic ECS Implementation:** Deterministic scheduling and parallel system execution.
* **2D Rendering Pipeline:** Sprites, textures, simple shaders.
* **Input Handling:** Keyboard, mouse, gamepad.
* **Audio Playback:** Basic sound effects and music.
* **Source-Driven Build System:** Derives configuration from assets.
* **Component-First Project Scaffolding:** Auto-generated asset wrappers
* **Initial Standard Asset Support:** 3D/scenes (**glTF/.glb**, **FBX**, **OBJ**), textures (**PNG/JPEG/TGA/DDS**), audio (**WAV/OGG/MP3**), shaders (**GLSL/WGSL**), UI/animation (**SVG**, **BMFont/AngelCode**); **no proprietary formats**.
* **Cargo Integration:** Modular components as crates.
* **Basic Debugging/Profiling Lifecycle Events:** Frame timing and entity counts.

This scope ensures YAGE can build small but real games while proving its architectural principles.

### Milestones & Acceptance Gates

#### M0 — Foundations
**Scope:** kernel loop, scheduler phases, minimal ECS API, platform time/events, logs/errors.  
**Done when:**
* Engine runs headless fixed step (60 Hz) and exits cleanly with `ExitCode::SUCCESS`.
* **MB-ECS-01** variance: coefficient of variation ≤ 5% across 30 samples on DESKTOP-MID-NV.
* Deterministic replay: fixed-seed run produces identical world tick hashes across 3 consecutive runs.

#### M1 — First Pixel (Hello Triangle)
**Scope:** render graph skeleton, GPU backend traits, swapchain + present, “Hello Triangle” pass.  
**Done when:**
* Hello Triangle renders on **DESKTOP-MID-NV** and **MAC-AS** with VSYNC off.
* **MB-REND-01** at 1080p: p95 frame time ≤ [TBD] ms on DESKTOP-MID-NV; no stutter > [TBD] ms.
* Reflection validation rejects mismatched pipelines; LKG pipeline remains bound on error.

#### M2 — Source-Driven Assets & Hot Reload
**Scope:** content-addressed VFS, `yage-pack --watch`, shader/material/texture derivations, hot reload at `FrameBegin`.  
**Done when:**
* Changing a shader or texture triggers a reload within ≤ [TBD] ms p95; last-known-good never drops.
* **MB-LOAD-01** p95 time-to-ready ≤ [TBD] ms on DESKTOP-MID-NV.
* Cache manifests (`inputs`, `toolchain`, `hash`) are written atomically; variant resolution picks a device-native format.

#### M3 — Playable 2D Sample
**Scope:** small sample (physics + sprites + audio), input mapping, scene bootstrap via assets.  
**Done when:**
* **IB-2D-01** achieves ≥ 60 FPS p95 on DESKTOP-MID-NV and LAPTOP-INTEL-iGPU at 1080p.
* No scheduler write/write conflicts at runtime (detected at system registration).
* Packaging includes runtime + assets; start-to-first-frame ≤ [TBD] s on cold start.

#### M4 — Perf & CI Hardening
**Scope:** perf gates, baselining, triage automation, artifact uploads (JSON traces + CSV). 
**Done when:**
* CI fails PRs on > **2% p95** regressions in any benchmark on any target in the platform matrix.
* Baselines refresh only on release branches with signed report; auto-bisect posts culprit range to PR.
* SBOM + third-party notices attached to release artifacts. [TBD: retention policy]

#### Risks & Mitigations (MVP)
* **Driver variance / VSYNC leakage** → Pin drivers per Target Platform Matrix; disable OS power saving; pre-warm pipelines.
* **Non-deterministic tools** → Pin toolchain versions; content-address all derivations; sandbox or ban non-deterministic transforms.
* **Shader compile cost** → Precompile to DXIL/SPIR-V/MSL in `yage-pack`; hot-reload swaps only after successful creation.
* **Asset complexity creep** → Keep transforms pure; reject schema changes during MVP unless tied to a milestone acceptance gate.

---

### Future Enhancements

Beyond the MVP, YAGE can expand into richer functionality while preserving modularity:

* **3D Rendering:** GPU pipelines, mesh loaders, and material systems, grounded in **standard scene formats** (**glTF/.glb**, **FBX**, **USD**) and PBR material conventions (e.g., glTF material extensions).
* **Advanced Physics:** 3D rigid bodies, soft bodies, and constraints with collider data from standard meshes or **glTF extras**/**USD** metadata; consider **URDF** where appropriate.
* **Networking Stack:** Deterministic lockstep, client-server, and rollback netcode.
* **Scripting Integration:**: Capability-scoped **WASM module** bindings and optional **Lua**; define minimal stable ABIs and sandboxing policies.
* **Editor Tooling:** Optional visual editors, asset inspectors, and level editors as **adapters** over standard pipelines (e.g., Blender glTF export, **Rive/Lottie** animation tooling).
* **Hot-Reloading:** Assets and logic with **built-in validators** for **glTF**, **Rive/Lottie JSON**, **SVG**, and shader compilation checks (**GLSL/WGSL/HLSL**).
* **Platform Targets:** Beyond desktop - web (via **WASM**), mobile, and consoles.
* **Community-Driven Plugin Registry:** Reusable modules (importers, schema validators, behavior bindings) published as Cargo crates with quality gates (docs, tests, benchmarks).
* **Game/Content Lifecycle Support:** Extend the engine’s lifecycle model beyond the core runtime loop to enable stage-driven asset and pipeline management (e.g., expansions, seasonal events, tutorial → midgame → late-game → live events) with dynamic validated transitions, asset swaps, schema-versioning tools, and lifecycle-aware tooling.

These enhancements expand YAGE into a competitive, production-ready engine while keeping its modular philosophy intact.

---

### Open Questions / TBDs

Several areas remain open for experimentation and design refinement:

* **ECS Model:** Should YAGE adopt an existing ECS pattern (e.g., archetypal, sparse set) or innovate a hybrid model optimized for FP patterns?
  * **Resolution Plan:** M0 (Foundations) and validated again in M3 via IB-2D-01.
  * **Decision Criteria:** iteration throughput (entities/sec), cache miss rate, ergonomics (boilerplate per component), safety (count of `unsafe` blocks).
  * **Experiments:** implement MB-ECS-01 and 2–3 system archetypes across candidates (sparse-set, archetype, hybrid SoA); run on 3 target platforms.
  * **Acceptance Gates:** ≥ baseline +3% across all platforms; no increase in `unsafe`; codegen overhead < N lines/component on average.
* **Standards Policy For Assets:** To what extent should YAGE **require standard formats** (glTF, USD, PNG/JPEG/TGA/DDS, WAV/OGG/MP3, GLSL/WGSL/HLSL, SVG, Rive/Lottie, BehaviorTree JSON) and **disallow proprietary encodings**? What is the policy on **custom glTF/USD extensions** vs. **sidecar JSON**—and how are validators and schema versioning enforced?
  * **Resolution Plan:** M2 (Assets & Hot Reload) using MB-LOAD-01 and packaging trials.
  * **Decision Criteria:** import friction (steps to “first pixels”), schema stability (minor release breakage rate), build determinism (artifact cache hit %).
  * **Experiments:** compare glTF/USD pipelines using source-driven derivation vs. custom meta formats; validate with CI (Serde/JSON Schema).
  * **Acceptance Gates:** ≥ 90% artifact-cache hit on rebuild; zero nondeterministic diffs; ≤ 1 schema-breaking change per minor version.
* **Configuration Style:** Should declarative manifests dominate, or should Rust code be the preferred configuration surface?
  * **Resolution Plan:** M3 (2D Sample) by authoring the sample both ways and comparing review churn/time-to-change.
  * **Decision Criteria:** expressiveness (features covered declaratively), auditability (diff clarity), incidence of “escape to code.”
  * **Experiments:** author a small sample both ways (manifest-first vs. Rust-composed); measure review churn and time-to-change.
  * **Acceptance Gates:** manifest-first covers ≥ 80% of knobs; code path remains available with no perf regressions.
* **Networking Direction:** Should YAGE provide batteries-included netcode or remain purely plugin-driven?
  * **Resolution Plan:** *deferred beyond MVP*; collect findings from M3’s timing hooks for later exploration.
  * **Decision Criteria:** latency budget adherence, determinism/rollback friendliness, maintenance surface.
  * **Experiments:** prototype rollback lockstep sample; benchmark with IB-2D-01 under induced jitter/packet loss.
  * **Acceptance Gates:** meets jitter tolerance at 60 FPS on mid-tier hardware; plugin API remains orthogonal.
* **Editor Philosophy:** Should visual tools remain minimal and optional, or evolve into first-class components?
  * **Resolution Plan:** M2 (hot-reload ergonomics) vs. M3 (iteration loops/hour); ship whichever hits the gate **without** bloating the runtime.
  * **Decision Criteria:** time-to-iterate (edit→preview), onboarding time, binary size/complexity cost.
  * **Experiments:** hot-reload shader/material editor vs. minimal inspector-only; measure iteration loops per hour.
  * **Acceptance Gates:** iteration speedup ≥ 25% with no material complexity increase for core runtime.

These TBDs will be addressed iteratively, with community input shaping the long-term vision.
