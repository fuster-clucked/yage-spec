## Developer Workflow

### Project Setup and Structure

YAGE projects are structured as **Rust-First applications**. Each game is a Cargo project, with the engine configured as a set of dependencies and modules.

* **No hidden project files:** all configuration is explicit and version-controlled.
* **Composable dependency model:** games include only the YAGE components they require.
* **Rust integration:** developers use idiomatic Rust tooling (Cargo, rustc, clippy, rustfmt).

YAGE favors a **component-first** layout where code and assets live together under feature folders. There is **no hard requirement** to separate `src/` and `assets/`, for example; teams may still do so, but the default guidance is to co-locate by concept for cohesion and team ownership. YAGE’s build system **discovers assets and derives configuration at build time**, keeping everything explicit and version-controlled.

#### Example: Entity-Centric Layout

```
/game_project
  Cargo.toml
  /player
    mod.rs           # feature module root (re-exports model/view/system)
    model.rs         # player data/components
    system.rs        # ECS systems and logic
    view.rs          # rendering and UI wiring for the player
    hero.png         # co-located asset(s)
    footstep.ogg
  /enemy
    mod.rs
    model.rs
    system.rs
    view.rs
    grunt.glb
    grunt_albedo.png
  /ui
    mod.rs
    hud.rs
    font.ttf
  main.rs            # app entry point; assembles features
```

#### Other Valid Patterns

Teams may organize by systems or layers, when appropriate, or mix strategies:

```
/physics/{ mod.rs, broadphase.rs, ... }
/audio/{ mod.rs, mixer.rs, click.wav }
/levels/{ level1.json, level2.json, level3.json }
/rendering/{ pipelines.rs, sprite_shader.wgsl }
```

YAGE’s discovery tolerates multiple patterns in a single project; choose what maps best to ownership and iteration speed.

#### Generated Asset Modules

At build time, YAGE **auto-generates small Rust modules** that provide type-safe names for discovered assets in each feature folder. This makes assets addressable lexically from code without stringly-typed lookups.

```rust
use crate::player::assets::HERO_SPRITE;
use crate::enemy::assets::GRUNT_MESH;
renderer.draw_sprite(HERO_SPRITE);
spawn_enemy(GRUNT_MESH);
```

**How It’s Produced:** a `build.rs` scans folders, fingerprints files, and emits code into `OUT_DIR` (Cargo standard). For small assets YAGE may embed bytes directly; for large assets it exposes content-hashed paths via lightweight loaders. All of this aligns with YAGE’s **build-time derivation** and **transparent, reproducible** philosophy.

#### Design Notes

* **Embedding Policy:** Use standard asset containers and streaming strategies with explicit thresholds; do not repack into proprietary bundles by default. Small and frequently accessed assets (e.g., icons, tiny sprites, short SFX) may be embedded; large assets (e.g., high-res textures, long audio, large meshes/scenes) are streamed.

| Asset Type        | Typical Formats             | Packaging & Delivery                                                                 | Retention Policy                                                                                     | Platform Overrides                                  |
|-------------------|-----------------------------|--------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------|-----------------------------------------------------|
| Small UI Images   | PNG, TGA, DDS               | Embed ≤256 KB assets into UI packfile; otherwise packfile with mip levels            | Keep resident during active UI stages; LRU-evict least-recently-used on memory pressure               | Web/Mobile: embed threshold ≤128 KB                 |
| Short SFX         | WAV, OGG, MP3               | Audio packfile with cue sheet; preload per stage                                     | Keep resident for current stage; recycle on stage exit                                                | Mobile: stream on-demand for long ambience          |
| Large Textures    | PNG, JPEG, DDS              | Streamed from VFS/packfile; demand-loaded mips                                      | Pin base mip on first use; drop highest LODs first under pressure                                     | Web: cap max resolution via config                  |
| Meshes/Scenes     | glTF (.gltf/.glb), USD      | Scene bundles; deferred streaming of mesh/anim chunks                                | Unload on stage exit; allow shared static meshes to persist across stages (opt-in)                    | Mobile: prefer .glb; disable heavy USD features     |
| Fonts/Vector Art  | TTF/OTF, BMFont, SVG        | Bake glyph atlases; cache vector paths                                               | Keep primary UI font atlases hot; evict alternates via size-bounded cache                             | Web: optionally use pre-baked WOFF2 variants        |
| Scripts/Behaviors | Lua, WASM                   | Content-addressed modules; hashed artifact cache                                     | Keep JIT/compile artifacts across hot-reloads; purge on major version bump                           | Web: WASM only; no native JIT                       |

*Stage-specific asset and streaming overrides are declared via the Configuration System and resolved by the Effective Merge Order.*

* **Hot Reload Support:** The file-watcher detects changes to recognized formats (e.g., **glTF/.glb**, **FBX**, **OBJ**, **USD**, **PNG/JPEG/TGA/DDS**, **WAV/OGG/MP3**, **GLSL/WGSL/HLSL**, **SVG**, **Rive/Lottie JSON**, **Lua**, **WASM modules**). Generated symbols remain **stable**; reloading **rebinds component data** behind those symbols. On reload:
  * **Data-only assets** (meshes, textures, audio) refresh in place with handle identity preserved.
  * **Scene/graph assets** (e.g., glTF, USD) trigger **incremental ECS updates** for affected entities/components.
  * **Behavior assets** (Lua/WASM) are hot-swapped with **capability-scoped** interfaces; failures roll back to the previous version atomically.
  * Shaders recompile and re-link; failures keep the last good pipeline active with errors surfaced to the console/IDE.

* **Macro Sugar:** Optional `asset!("player/hero.png")` expands to the generated symbol for convenience.

* **Custom Derivations:** Projects can plug in preprocessors (e.g., shader compilation, texture compression).

#### Security & Sandboxing (Behavior Assets)

* **Capability-Scoped Host APIs:** Lua/WASM modules receive only the capabilities they declare (deny-by-default).
* **Deterministic Mode:** Option to disable non-deterministic APIs (time, RNG without seed) for reproducible runs.
* **Resource Limits:** Per-module CPU time slice and memory ceilings; enforced during hot reload and runtime.
* **Safe Rollback:** Failed reloads revert atomically; previous module stays resident and active.
* **Auditability:** All behavior asset loads/reloads are logged with content hash, issuer, and granted capabilities.

#### Conventions and Recommendations

* **One Feature Per Folder:** Prefer a single coherent concept per folder (player, enemy, UI, physics). Split only when a feature’s surface becomes unwieldy.
* **Keep Assets Close:** Place small or frequently-touched assets alongside the feature; large or shared assets can live in a shared folder referenced by the feature.
* **Curate The Public API:** Re-export only what consumers need from each feature’s `mod.rs` (example below). This keeps dependencies tidy and encourages encapsulation.
* **Tests Live With Features:** Feature-specific tests (and sample assets) can be co-located (e.g., `player/tests/`, `player/sample_assets/`) to preserve context.

#### Example: Feature Re-Exports

In `player/mod.rs`, consolidate the feature’s public surface and keep internals private by default:

```rust
pub mod assets; // generated by YAGE
mod model;
mod system;
mod view;

pub use assets::HERO_SPRITE;   // curated asset handle
pub use model::Player;         // public data/types
pub use system::PlayerControl; // public systems/events
```

#### Common Pitfalls

* **Layer-First Regressions:** Avoid reintroducing global `src/model,` `src/view`, or `src/system` buckets. They scatter a single feature across the tree and erode ownership.
* **Asset Drift:** When moving assets, keep names stable where possible to avoid churn in generated symbols. The generator will report collisions or renames during build.
* **Over-Public APIs:** If everything is `pub`, nothing is encapsulated. Prefer `pub(crate)` and explicit re-exports from the feature root.

---

### Lifecycle-Aware Development

In addition to supporting entity-based asset organization, YAGE provides explicit mechanisms for managing game lifecycle complexity. Developers must be able to evolve assets and pipelines over time, ensuring smooth transitions between stages (e.g., tutorial, midgame, expansion content, seasonal events).

* **Defining Lifecycle Stages**
  * Developers can declare named lifecycle stages (e.g., `onboarding`, `core-gameplay`, `late-game`, `seasonal-event`).
  * Each stage can reference:
    * Specific asset bundles or overrides.
    * Pipeline variations (e.g., high-fidelity rendering, AI behaviors, UI skins).
  * Stages may be sequential or branching, depending on the game design.

* **Tagging Assets by Lifecycle**
  * Assets can be annotated with lifecycle metadata.
    * Example: `character_model_v1 [stage=early]`, `character_model_v2 [stage=late]`.
  * This ensures that the correct version is automatically swapped in as the lifecycle advances.
  * Supports both additive lifecycles (building new assets on top of old) and substitutive lifecycles (replacing older assets).

* **Pipeline Overrides**
  * Developers can define stage-specific pipeline overrides.
    * Example: In tutorial stage, simplified physics pipeline; in late-game, advanced particle effects pipeline.
  * Overrides inherit from base pipelines, minimizing duplication.

* **Testing and Validation**
  * YAGE tooling includes lifecycle simulation:
    * Developers can run the game in a specific stage to test assets and pipelines in isolation.
    * Transition testing validates that asset swaps, memory unloading, and pipeline transitions occur without error.
  * **Schema Conformance Checks:** Validate assets against **established schemas and validators**:
    * **glTF 2.0** (scenes, nodes, animations) via standard validators; **USD** where applicable.
    * **Rive/Lottie JSON** for animated UI; **SVG** for vector UI.
    * **Shaders** (GLSL/WGSL/HLSL) compile checks as part of the pipeline.
    * **Behavior definitions** (e.g., well-known behavior tree/state machine formats) checked for structural validity; **Lua/WASM** modules verified for required exports and capability scopes.
  * **Automated Validation:** Missing assets, incompatible overrides, or schema violations fail fast in CI and local builds with clear diagnostics.

* **Iterative Development Workflow**
  * Developers can incrementally define lifecycles:
    * Start with a minimal lifecycle (early → core).
    * Add advanced stages over time (expansions, events).
  * This workflow supports agile development where lifecycle complexity can grow with project needs.

* **Collaboration and Tooling**
  * Integration with source control and asset management systems supports branching per lifecycle stage.
  * Teams can work in parallel on different lifecycle stages without interfering with one another.
  * CI/CD pipelines can automatically validate lifecycle-specific builds.

---

### Namespace Mapping Rules

YAGE generates Rust modules for discovered assets using **the same rules Rust applies to source modules**, so asset references read and behave like normal Rust names (just generated at build time). This supports co-located, component-first layouts while keeping everything explicit and version-controlled.

#### Module Hierarchy

* Each **directory** becomes a **module**; each **non-Rust file** inside it becomes a **symbol** inside an `assets` submodule (per feature).
* If a directory already has Rust code (e.g., `player/mod.rs`), the generator **adds** `player::assets` rather than polluting the feature’s root.

**Example (Entity-Centric Layout):**

```
/player
  mod.rs
  model.rs
  hero.png
  footstep.ogg
```

Generated access:

```rust
use crate::player::assets::{HERO, FOOTSTEP};
```

#### Identifier Naming

* **Modules** derived from directories use **snake_case**.

* **Asset Values** are exported as **SCREAMING_SNAKE_CASE** constants or zero-sized markers with typed getters.

* **File stem → identifier base:**
  * Normalize Unicode (NFKC), trim whitespace.
  * Convert to snake case for modules; to screaming snake for values.
  * Replace invalid characters (`-`, `.`, ` ` `/`) with `_`.
  * If the name starts with a digit, prefix with `_`.
  * If it is a Rust **keyword** (`mod`, `type`, `match`, …), suffix with `_`.

**Examples**

| File name | Base symbol | Notes |
| ----- | ----- | ----- |
| `hero.png` | `HERO` | Type = image |
| `grunt-albedo.PNG` | `GRUNT_ALBEDO` | Case/sep normalized |
| `shader.wgsl` | `SHADER` | Type = shader |
| `3d-model.glb` | `_3D_MODEL` | Leading digit prefixed |
| `match.wav` | `MATCH_` | Keyword suffixed |
| `menu@2x.png` | `MENU_2X` | Non-alnum collapsed to `_` |

#### Typing and API Shape

* Each symbol exposes a **type-safe handle** (e.g., `AssetRef<Image>`, `AssetRef<Audio>`, `AssetRef<Shader>`), inferred from extension and/or metadata.

  **Two Access Patterns:**

  ```rust
  pub const HERO: AssetRef<Image> = /* generated */
  ```

  ```rust
  pub fn hero() -> AssetRef<Image> { /* generated */ }
  ```

#### Name Collisions and Disambiguation

* Type suffixes are added when needed (`HERO_IMAGE`, `HERO_AUDIO`).
* If conflicts remain, a short stable hash is appended (`HERO_IMAGE_A1B2`).
* Collisions can also be surfaced as compile-time errors with hints.
* Hashing is stable across platforms and includes the normalized relative path. Use **BLAKE3-256** with a per-project salt (recorded in config). Hashes are lowercase hex; input normalization includes path separators and UTF-8 NFC.

#### Visibility and Re-Exports

* Generated modules are **`pub(crate)`** by default.

  Features can re-export curated assets from `mod.rs`:

```rust
pub mod assets;
pub use assets::HERO;
```

#### Determinism and Rebuild Behavior

* Symbol generation is deterministic.

* Codegen writes to `OUT_DIR`; only changed assets trigger rebuilds.

* Content hashes are embedded in dev builds for drift detection.

* **Recognized Standard Formats (non-exhaustive):**
  * **3D/Scenes and Animation:** glTF (.gltf/.glb), FBX, OBJ, USD
  * **Textures and Materials:** PNG, JPEG, TGA, DDS
  * **Audio:** WAV, OGG, MP3
  * **Shaders:** GLSL, WGSL, HLSL
  * **UI/Fonts/Vector:** SVG, Rive (.riv), Lottie (.json), TTF/OTF, BMFont
  * **Behavior:** common behavior-tree/state-machine descriptors (JSON/XML), **Lua**, **WASM modules**

* **Selective/Minimal Rebuilds:** Dependency tracking ensures that edits to an asset only rebuild the **consuming component set** (e.g., editing a `.glb` updates scene/physics bindings but does not touch unrelated audio pipelines).

#### Examples

**Co-located (Entity-First):**

```
/enemy
  mod.rs
  grunt.glb
  grunt_albedo.png
```

```rust
use crate::enemy::assets::{GRUNT_MESH, GRUNT_ALBEDO_IMAGE};
```

**System-Centric:**

```
/audio
  mod.rs
  click.wav
  whoosh.ogg
```

```rust
use crate::audio::assets::{CLICK_AUDIO, WHOOSH_AUDIO};
```

**Mixed Layout:**

```
/ui/hud.rs
/ui/font.ttf
/rendering/sprite_shader.wgsl
```

```rust
use crate::ui::assets::FONT;
use crate::rendering::assets::SPRITE_SHADER;
```

---

### Asset Management and Source Control

YAGE treats assets as first-class citizens, on equal footing with source code. They are co-located with features by default, can be referenced lexically through generated wrappers, and are always included in the same version control workflow as Rust code. This ensures reproducibility and makes asset usage transparent in collaborative teams.

#### Guiding Principles

* **Version-Controlled Assets**: All assets are committed alongside code, subject to the same branching, review, and CI/CD checks.
* **Deterministic Builds**: Build-time wrappers guarantee that asset references are stable, type-safe, and reproducible across machines.
* **Flexible Organization**: Assets may be co-located with features, grouped by system, or centralized; YAGE’s discovery and codegen adapt to the chosen layout.
* **Format-Driven Handling**: Adding a supported file type (e.g., `.glb`, `.png`, `.ogg`) triggers automatic inclusion in the build pipeline. Developers never configure imports in external GUIs; assets are detected and modularized at build time.

#### Asset Versioning and VCS Strategy

* **Textual Assets** (e.g., JSON, YAML, shader sources, tile maps) are stored directly in Git, diffable and reviewable like code.

* **Binary Assets** (e.g., images, audio, 3D models) are also versioned, but may require special handling to avoid repository bloat:
  * **Small-To-Medium Binaries**: Stored directly in Git (preferred when practical).
  * **Large Binaries**: Use Git LFS, or configure external storage backends integrated with CI/CD. YAGE does not impose one solution but ensures that generated wrappers remain consistent across setups.

* **Metadata Files**: Optional `.meta` or sidecar descriptors (e.g., compression settings, variants) are treated as versioned sources, not hidden build products.

#### Branching and Collaborative Workflow

* Assets evolve through the same feature branch workflow as code. Designers and developers can iterate in parallel without collisions.
* Generated wrappers (asset modules in `OUT_DIR`) are **not committed**; instead, they are rebuilt on every machine to guarantee consistency and freshness.
* When assets move or are renamed, the generator will surface compile-time errors for stale references, guiding contributors to update code accordingly.

#### Continuous Integration and Delivery

* CI/CD pipelines run the generator as part of normal builds, ensuring asset references are always valid.

* Optional checks can enforce asset policies, such as:
  * Rejecting oversized binaries without LFS.
  * Validating required metadata (e.g., license headers, compression level).
  * Ensuring asset naming consistency for generated symbols.

* Build artifacts (compiled shaders, compressed textures, baked meshes) can be cached or published as CI/CD outputs but are not committed to VCS.

#### Best Practices and Recommendations

* **Keep Assets Human-Accessible**: Prefer formats that remain inspectable and modifiable outside YAGE.
* **Avoid Opaque Pipelines**: Preprocessing steps (compression, shader compilation) should be scripted and reproducible, never manual.
* **Test With Representative Assets**: Place sample assets alongside features to catch pipeline errors early.
* **Audit Asset Growth**: Track repository size and asset churn to avoid long-term VCS performance issues.

#### Common Pitfalls

* **Binary Sprawl**: Dumping unoptimized assets directly into Git without size controls leads to bloat.
* **Untracked Generated Files**: Accidentally committing `OUT_DIR` or build-generated modules can destabilize reproducibility.
* **Naming Drift**: Renaming assets without refactoring references leads to broken builds; rely on generator errors to catch and fix immediately.

---

### Build Process and Tooling

YAGE’s build process extends standard Rust tooling with asset-aware code generation. Developers interact with Cargo as usual, while YAGE’s build scripts ensure assets and systems are integrated seamlessly into the compiled game. The process remains explicit, reproducible, and does not introduce hidden configuration files or proprietary pipelines.

#### Guiding Principles

* **Rust-First Workflow**: Cargo, `rustc`, `rustfmt`, and `clippy` remain the foundation. YAGE builds feel identical to any Rust project.
* **Build-Time Derivation**: Assets, configuration, and wrappers are derived at compile time through deterministic build scripts.
* **Format-Driven Handling**: Supported file types (e.g., `.glb`, `.png`, `.ogg`) are automatically included in the pipeline—no GUI import steps required.
* **No Hidden State**: All transformations (e.g., shader compilation, texture compression) are driven by visible, version-controlled files and scripts.
* **Reproducibility**: Two developers with the same repo state get identical builds, independent of local environment quirks.

#### Standard Workflow

* **Cargo build**: Invokes `build.rs` scripts for YAGE components.
* **Asset Discovery**: The build script scans project folders for supported formats, generates lexical wrappers in `OUT_DIR`, and fingerprints files for rebuild detection.
* **Optional Preprocessing**: If preprocessors are registered (e.g., GLSL to SPIR-V, PNG to compressed texture), they run as deterministic build steps.
* **Compile and Link**: Rust code and generated wrappers are compiled together into the final binary.
* **Run and Test**: Developers run `cargo run` or `cargo test` as in any Rust project.

#### Extensibility

* **Custom Build Lifecycle Events**: Projects may register additional transformations through Cargo build scripts or YAGE plugins.
* **Deterministic Preprocessors**: All transformations must be reproducible from source assets (no opaque binaries checked into VCS).
* **Configurable Outputs**: Preprocessing results (e.g., compressed textures) can be cached or emitted into CI/CD artifacts, but not committed to source control.

#### CI/CD Integration

* CI builds run the same pipeline, guaranteeing that wrapper generation and preprocessing steps succeed on clean machines.
* Optional CI checks can validate asset sizes, naming conventions, or forbidden formats.
* Build outputs (e.g., compressed assets, platform-specific packages) can be stored in artifact repositories for deployment.

#### Best Practices

* **Keep build.rs minimal**: Centralize asset scanning and wrapper generation, avoid scattering logic.
* **Use Feature Flags**: Enable or disable subsystems (physics, audio, networking) via Cargo features.
* **Automate Preprocessing**: Never rely on manual conversion pipelines outside version control.
* **Validate Locally Before CI**: Run `cargo build --release` and `cargo test` with representative assets to catch errors early.

#### Common Pitfalls

* **Overcomplicated Build Scripts**: Keep `build.rs` scripts declarative; imperative hacks reduce reproducibility.
* **Untracked Transformations**: Avoid running manual preprocessors outside the build; every transformation must be in source or script.
* **Ignoring OUT_DIR Hygiene**: Never commit generated wrappers or intermediate files; these are reproducible at build time.

---

### Testing and Quality Assurance

Testing in YAGE is treated as a core development activity, not an afterthought. Because both code and assets are first-class citizens, tests must validate not only systems and logic but also the integrity and correctness of assets as they flow through the build pipeline. The goal is to ensure that YAGE projects remain stable, reproducible, and trustworthy as they grow in complexity.

#### Guiding Principles

* **Rust-Native Testing**: Leverage Cargo’s built-in test runner (`cargo test`) for unit and integration tests.
* **Asset-Inclusive QA**: Treat assets as testable artifacts; corrupted, missing, or mismatched assets should fail tests deterministically.
* **Automation-First**: All tests must be runnable in CI/CD without manual intervention.
* **Deterministic Outcomes**: Tests must be reproducible across machines; avoid environment-specific assumptions.
* **Progressive Layering**: Start with unit tests, expand into integration and system tests, and complement with automated asset validation.

#### Types of Tests

* **Unit Tests**: Validate small pieces of logic (e.g., ECS systems, math utilities, physics integration steps).
* **Integration Tests**: Check interaction between multiple systems or features (e.g., player controls with physics and rendering).
* **Asset Validation Tests**: Ensure required assets exist, are loadable, and conform to expected formats. Generated asset wrappers help detect issues early.
* **Golden Tests**: Compare rendered outputs or serialized states against known-good references. Useful for rendering correctness, UI layout, or level serialization.
* **Performance Regression Tests**: Lightweight benchmarks run under `cargo test --release` or CI to catch unexpected slowdowns.

#### Testing Workflow

* **Write Unit Tests:** Alongside the features they validate (`player/tests/`, `physics/tests/`).
* **Add Integration Tests:** Under `/tests/` at the project root for cross-feature behaviors.
* **Use Generated Asset Wrappers:** Assert that assets are correctly registered (e.g., `assert!(player::assets::HERO_SPRITE.exists());`).
* **Include Sample Assets:** Keep placeholder assets small and deterministic for test purposes.
* **Automate CI/CD Checks:** Ensure builds fail fast if tests regress or assets are invalid.

#### Best Practices

* **Keep Tests Fast**: Unit and integration tests should complete in seconds, not minutes, to encourage frequent runs.
* **Use Representative Assets**: Include minimal but realistic assets in tests (small PNGs, short audio clips).
* **Segregate Heavy Tests**: Place expensive or long-running tests (e.g., large scene loads) behind feature flags or separate CI jobs.
* **Test Error Handling**: Simulate missing/corrupted assets to ensure the engine fails gracefully.
* **Automate Golden Tests**: Store golden references under version control and regenerate them intentionally when behavior changes.

#### Common Pitfalls

* **Neglected Assets**: Only testing code leads to surprises when assets break the build.
* **Non-Deterministic Tests**: Randomized seeds or environment-specific assumptions lead to flaky results.
* **Over-Reliance On Manual QA**: Without automated coverage, regressions slip through.
* **Bloated Test Assets**: Oversized test files slow down CI/CD and inflate repositories.

---

### Debugging and Profiling

Debugging and profiling in YAGE emphasize transparency and developer empowerment. The tooling should integrate seamlessly with standard Rust workflows, while exposing enough visibility into systems, ECS state, and assets to track down issues efficiently. Profiling focuses on performance bottlenecks in both code and assets, ensuring that games remain responsive and predictable.

#### Guiding Principles

* **Rust-Native First**: Standard tools like `cargo run`, `cargo test`, and `RUST_BACKTRACE` remain the baseline.
* **Observability Built-In**: ECS systems, asset pipelines, and renderers expose introspection lifecycle events to aid debugging.
* **Deterministic Reproduction**: Debugging relies on reproducible runs, not “hopeful reruns” with different results.
* **Performance Visibility**: Profiling is lightweight and integrated; it highlights slow paths without requiring external GUIs.
* **Non-Intrusive**: Debugging aids can be compiled out or disabled in release builds for zero overhead.

#### Debugging Workflow

* **Backtraces**: Enabled with `RUST_BACKTRACE=1`, standard Rust panic traces provide function-level insight.
* **Structured Logging**: Features and systems emit structured logs (`tracing`-compatible) with categories for ECS, rendering, input, etc. Developers can filter logs per subsystem.
* **Introspection APIs**: Systems can expose runtime state (e.g., entity counts, active components) for inspection in debug builds.
* **Asset Verification**: Generated asset wrappers can include runtime checks to confirm load success, surfacing meaningful errors instead of silent failures.
* **Visual Overlays and Instrumentation**: Optional in-engine overlays (FPS counter, ECS stats, asset load times) and lightweight visualization (wireframes, collision boxes, frame graphs) can be toggled at runtime for rapid feedback.

#### Profiling Workflow

* **Lightweight Timers**: Built-in instrumentation around ECS system execution, rendering passes, and asset loaders.
* **Frame Breakdowns**: Developers can enable detailed per-frame stats in debug builds (CPU time by system, GPU submission times).
* **Sampling Profilers**: YAGE supports running under external profilers (`perf`, `Instruments`, `VTune`) without modification.
* **Deterministic Benchmarks**: Combined with the benchmarking strategy, developers can detect regressions or hotspots under controlled conditions.
* **Asset Impact Analysis**: Profiling includes asset-level metrics (e.g., time to load a model, cost of a shader compile) to guide optimization.

#### Best Practices

* **Use Debug Overlays Sparingly**: Enable only when needed; overlays can distort performance in tight loops.
* **Trace Subsystem Boundaries**: Focus logging and timers around ECS system entry/exit points to reveal real bottlenecks.
* **Profile With Representative Assets**: Don’t benchmark against trivial placeholder data; real workloads matter.
* **Keep Debug Builds Fast Enough**: Over-instrumentation can make debug iterations painful; balance visibility with speed.
* **Record Seeds For Determinism**: When debugging nondeterministic behavior, log seeds or inputs so runs can be replayed.

#### Common Pitfalls

* **Silent Asset Failures**: Without runtime checks, missing or corrupted assets cause confusing downstream errors.
* **Over-Logging**: Verbose logs can drown signal in noise; use subsystem filters.
* **Profiling In Isolation**: Micro-benchmarks are useful, but whole-frame profiling better reflects game performance.
* **Debugging Release-Only Bugs**: Over-aggressive assumptions in debug builds can hide issues; always test representative release builds too.
* **Skipping Reproducibility**: Failing to capture seeds, inputs, or asset versions leads to non-repeatable bug reports.
