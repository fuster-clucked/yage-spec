## Roadmap

### MVP Scope

The Minimum Viable Product for YAGE should deliver a **lean but functional engine core** demonstrating the unique philosophy (Rust-first, FP-friendly, configurable, source-driven). MVP features include:

* **Engine Core Kernel:** Lifecycle management (init, update, shutdown).
* **Basic ECS Implementation:** Deterministic scheduling and parallel system execution.
* **2D Rendering Pipeline:** Sprites, textures, simple shaders.
* **Input Handling:** Keyboard, mouse, gamepad.
* **Audio Playback:** Basic sound effects and music.
* **Source-Driven Build System:** Derives configuration from assets.
* **Component-First Project Scaffolding:** Auto-generated asset wrappers
* **Initial Standard Asset Support:** 3D/scenes (**glTF/.glb**, **FBX**, **OBJ**), textures (**PNG/JPEG/TGA/DDS**), audio (**WAV/OGG/MP3**), shaders (**GLSL/WGSL**), UI/animation (**SVG**, **BMFont/AngelCode**); **no proprietary formats**.
* **Cargo Integration:** Modular components as crates.
* **Basic Debugging/Profiling Lifecycle Events:** Frame timing and entity counts.

This scope ensures YAGE can build small but real games while proving its architectural principles.

---

### Future Enhancements

Beyond the MVP, YAGE can expand into richer functionality while preserving modularity:

* **3D Rendering:** GPU pipelines, mesh loaders, and material systems, grounded in **standard scene formats** (**glTF/.glb**, **FBX**, **USD**) and PBR material conventions (e.g., glTF material extensions).
* **Advanced Physics:** 3D rigid bodies, soft bodies, and constraints with collider data from standard meshes or **glTF extras**/**USD** metadata; consider **URDF** where appropriate.
* **Networking Stack:** Deterministic lockstep, client-server, and rollback netcode.
* **Scripting Integration:**: Capability-scoped **WASM module** bindings and optional **Lua**; define minimal stable ABIs and sandboxing policies.
* **Editor Tooling:** Optional visual editors, asset inspectors, and level editors as **adapters** over standard pipelines (e.g., Blender glTF export, **Rive/Lottie** animation tooling).
* **Hot-Reloading:** Assets and logic with **built-in validators** for **glTF**, **Rive/Lottie JSON**, **SVG**, and shader compilation checks (**GLSL/WGSL/HLSL**).
* **Platform Targets:** Beyond desktop - web (via **WASM**), mobile, and consoles.
* **Community-Driven Plugin Registry:** Reusable modules (importers, schema validators, behavior bindings) published as Cargo crates with quality gates (docs, tests, benchmarks).
* **Game/Content Lifecycle Support:** Extend the engine’s lifecycle model beyond the core runtime loop to enable stage-driven asset and pipeline management (e.g., expansions, seasonal events, tutorial → midgame → late-game → live events) with dynamic validated transitions, asset swaps, schema-versioning tools, and lifecycle-aware tooling.

These enhancements expand YAGE into a competitive, production-ready engine while keeping its modular philosophy intact.

---

### Open Questions / TBDs

Several areas remain open for experimentation and design refinement:

* **ECS Model:** Should YAGE adopt an existing ECS pattern (e.g., archetypal, sparse set) or innovate a hybrid model optimized for FP patterns?
* **Standards Policy For Assets:** To what extent should YAGE **require standard formats** (glTF, USD, PNG/JPEG/TGA/DDS, WAV/OGG/MP3, GLSL/WGSL/HLSL, SVG, Rive/Lottie, BehaviorTree JSON) and **disallow proprietary encodings**? What is the policy on **custom glTF/USD extensions** vs. **sidecar JSON**—and how are validators and schema versioning enforced?
* **Configuration Style:** Should declarative manifests dominate, or should Rust code be the preferred configuration surface?
* **Networking Direction:** Should YAGE provide batteries-included netcode or remain purely plugin-driven?
* **Editor Philosophy:** Should visual tools remain minimal and optional, or evolve into first-class components?

These TBDs will be addressed iteratively, with community input shaping the long-term vision.
