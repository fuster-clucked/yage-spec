# YAGE (Yet Another Game Engine)

**Description:**  
A Rust-native, functional-friendly, highly configurable game engine that assembles fine-grained, orthogonal components into tailored runtimes - emphasizing source-driven assets and build-time derivation at its core.

---

## Introduction

This specification defines YAGE’s goals, scope, and technical foundations. It is organized into: **Core Philosophy** (design principles), **Architecture** (systems and data flow), **Developer Workflow** (conventions and processes), **Performance and Optimization** (zero-cost and safe parallel execution strategies), **Extensibility** (module system and integration pipelines), **Use Cases** (configurations and comparisons), **Roadmap** (MVP and future work), and **Appendices** (terminology and references).

### Project Overview

YAGE (Yet Another Game Engine) is a modern, Rust-native game engine designed to balance **functional programming principles, high performance, and configurability**. Unlike monolithic engines, YAGE is built from orthogonal, fine-grained components that can be composed into a tailored runtime. Its design is inspired by the flexibility of build systems like Webpack, where developers construct an engine configuration suited precisely to their game’s needs.

At its core, YAGE is **developer- and source-driven**: all game assets are managed in source control, and engine features are automatically derived from these assets at build time. This ensures a reproducible, transparent, and scalable workflow for teams of all sizes.

YAGE treats **assets as first-class source** and **code as glue**. Instead of inventing formats, YAGE binds **established, widely used standards** directly into ECS components and systems: 3D/scenes (**glTF/.glb**, **FBX**, **OBJ**, **USD**), textures (**PNG/JPEG/TGA/DDS**), audio (**WAV/OGG/MP3**), shaders (**GLSL/WGSL/HLSL**), UI/animation (**SVG**, **Rive**, **Lottie JSON**), and behavior descriptors (e.g., **BehaviorTree JSON**, optional **Lua** / **WASM** modules). This enables teams to use familiar tools (Blender, DCCs, Rive/Lottie, standard shader compilers) while keeping the engine lean and composable.

YAGE is also designed to support dynamic game lifecycles — enabling assets, systems, and pipelines to evolve fluidly across stages of play or content updates. This adaptability ensures the engine remains suitable for both traditional single-release games and continuously evolving live experiences.

### Goals

* **Rust-first implementation** leveraging safety, concurrency, and performance guarantees.
* **Functional programming friendliness**, enabling declarative patterns without sacrificing performance.
* **Highly configurable architecture**, allowing developers to assemble only the components they need.
* **Standards-first assets with schema-aware loaders**, enabling behavior and configuration to be expressed in **established formats** with optional **Lua/WASM** bindings under capability-scoped interfaces.
* **Source-driven workflow**, where assets and code live in source control and drive build-time behavior.
* **Performance without compromise**, ensuring composability does not introduce unnecessary overhead.

### Non-Goals

* Building a monolithic "batteries-included" engine with rigid defaults.
* Prioritizing visual tooling over source-driven workflows (editors may come later, but source remains primary).
* Locking into a single genre or rendering paradigm — YAGE is intentionally genre-agnostic.
* Abstracting away Rust — YAGE is for developers who embrace Rust’s language features.
* Creating proprietary asset formats or custom DSLs for content — YAGE prefers to bind **existing standards** rather than inventing new ones.

### Guiding Principles

* **Orthogonality:** components should be independent and composable without hidden couplings.
* **Transparency:** every transformation or build step should be observable and reproducible.
* **Zero-cost abstractions:** high-level expressiveness must compile down to efficient, optimized code.
* **Convention with flexibility:** provide smart defaults but never limit configuration.
* **Source (including assets) as the single source of truth:** all assets and engine configuration are version-controlled; assets prefer **standard, widely adopted formats**, with code acting primarily as glue.
