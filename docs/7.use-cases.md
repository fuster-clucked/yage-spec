## Use Cases

### Example Configurations

YAGE’s **configurable architecture** allows it to adapt to widely different game genres and scales. A few illustrative scenarios:

* **2D Platformer**
  * **Components:** 2D renderer, sprite animation, simple physics, input handling, audio playback.
  * **Asset-Driven Setup:** Adding sprite sheets enables animation systems automatically.
  * **Standard Formats:** Spritesheets (**PNG/TGA/DDS**), atlas manifests (e.g., JSON/Atlas), bitmap fonts (**BMFont/AngelCode**), 2D animation (**Spine JSON** / **Rive**).
  * **Benefits:** Minimal runtime footprint, fast iteration, CI/CD friendly.

* **3D First-Person Shooter**
  * **Components:** 3D renderer with GPU pipelines, mesh loader, physics, AI systems, input, audio, networking.
  * **Asset-Driven Setup:** Importing `.glb` models triggers mesh and material pipelines.
  * **Standard Formats:** Scenes and meshes (**glTF/.glb**, **FBX**, **OBJ**, **USD**); textures and materials (**PNG/JPEG/TGA/DDS**, glTF PBR material extensions); animations (**glTF animations**, **BVH**); physics colliders via **glTF extras** or standard collider meshes; shaders (**GLSL/WGSL/HLSL**); audio (**WAV/OGG/MP3**).
  * **Benefits:** high performance, concurrency-safe AI, tailored engine runtime without unnecessary subsystems.

* **Simulation/Strategy Game**
  * **Components:** ECS for large entity counts, deterministic simulation loop, custom data serialization, UI overlays.
  * **Asset-Driven Setup:** Configuration files define rulesets, ECS schema is auto-generated.
  * **Standard Formats:** Rulesets and data (**JSON/CSV** with established schemas; behavior trees/state machines in common JSON/YAML forms); UI (**SVG**, **Rive/Lottie JSON**); fonts (**TTF/OTF**, **BMFont**); optional scripting/logic via **Lua** or **WASM** modules.
  * **Benefits:** predictable performance for large-scale entity management, strong debugging/profiling tools.

These examples highlight that **YAGE adapts rather than prescribes**. Developers don’t need to strip away unused systems — they build only what they need.

---

### Lifecycle-Driven Scenarios

YAGE’s lifecycle architecture supports diverse gameplay and content evolution models. These examples illustrate how different genres and production styles can leverage lifecycle-aware pipelines and asset management.

* **Role-Playing Games (RPGs)**
  * **Evolution Across Chapters:** Characters, environments, and effects evolve across distinct game chapters.
  * **Adaptive Pipelines:** Early-game pipelines prioritize quick iteration and low fidelity, while later stages use advanced rendering and complex AI.
  * **Tagged Assets:** Asset sets are tagged by chapter or progression state, allowing smooth transitions as the player advances.

* **Live Service / Seasonal Games**
  * **Incremental Content Delivery:** New assets and features are introduced periodically without redeploying the entire game.
  * **Isolated Seasonal Pipelines:** Seasonal pipelines can be developed in isolation and activated dynamically at runtime.
  * **Lifecycle Tagging:** Ensures old event assets are safely unloaded once their period ends.

* **Sandbox/Simulation Games**
  * **Dynamic Expansion:** Player-driven progression can activate new pipelines dynamically (e.g., unlocking new biomes, vehicles, or physics systems).
  * **On-Demand Loading:** Lifecycle events allow assets and mechanics to be loaded on-demand without pausing gameplay.
  * **Parallel Pipelines:** Asset streaming and concurrent pipeline handling maintain performance during continuous world expansion.

* **Episodic/Narrative Titles**
  * **Modular Delivery:** Content is delivered in episodes, each with its own pipeline and asset scope.
  * **Lifecycle Configurations:** Each episode defines its own lifecycle configuration and dependencies.
  * **Persistent Systems:** Old episodes’ assets can be archived while retaining persistent systems like player state.

---

### Comparison To Existing Engines

YAGE shares some goals with modern engines but diverges in key ways:

| Engine | Key Traits | Contrast with YAGE |
| ----- | ----- | ----- |
| **Unity** | Visual editor, monolithic runtime, C\# | YAGE is **source-first**, modular, and Rust-based. |
| **Unreal Engine** | Feature-rich, C++ heavy, large footprint | YAGE favors **lean, configurable builds** with smaller runtimes. |
| **Godot** | Open-source, scripting-focused, flexible | YAGE prioritizes **Rust \+ FP-friendliness** and asset-driven derivation. |
| **Bevy** | Rust ECS engine, batteries included | YAGE emphasizes **fine-grained modularity** and **Webpack-like configurability**. |

**Standards-First Asset Model:** YAGE binds **established formats** (glTF, USD, PNG/JPEG/TGA/DDS, WAV/OGG/MP3, GLSL/WGSL/HLSL, SVG, Rive/Lottie, BehaviorTree JSON, Lua, WASM) directly to ECS systems and validators, avoiding proprietary encodings.

The result is an engine philosophy closer to a **game engine toolkit** than a monolithic product. Developers can craft their own engine instance, perfectly suited to their game, without the overhead of unused systems.
