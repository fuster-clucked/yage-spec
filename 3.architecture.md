## Architecture

### Component Model

At the heart of YAGE is a **component-based architecture**. Every engine feature — rendering, physics, input, asset pipelines, and entity management — is packaged as a discrete **orthogonal component**.

In practice, YAGE projects are often organized by **feature folders** (e.g., `player/`, `enemy/`, `ui/`) where code and assets are co-located. This reinforces the component-based philosophy and makes ownership intuitive for teams.

Core principles of the component model:

* **Orthogonality:** components operate independently with well-defined inputs and outputs.

* **Granularity:** features are broken into minimal, composable units (e.g., mesh renderer vs. full graphics pipeline).

* **Replaceability:** components can be swapped with custom implementations without breaking the rest of the engine.

* **Composable APIs:** components expose declarative, trait-driven interfaces that can be combined at compile time.

In YAGE’s architecture, assets are not just resources — they are **structural inputs** that directly compose the runtime. Each component declares the asset types it consumes and exposes a schema describing how those assets translate into ECS entities, components, and systems.

This means that assembling a game world often involves defining **asset graphs** rather than writing imperative setup code. For instance, a `scene.glb` (glTF 2.0 scene) might automatically instantiate entities with physics colliders, renderable meshes, and materials; a `ui.svg` or `menu.lottie.json` may register interactive regions and transitions; and a `behavior_tree.json` can link to a Lua or WASM behavior module providing decision logic.

The engine’s job is not to reinterpret these formats but to **bind them predictably** to components through schema reflection and system registration. Each system declares what asset formats it supports, using existing open specifications wherever possible. Developers extend this behavior by registering new schemas or bindings — not by modifying engine code.

This design avoids monolithic subsystems and ensures developers assemble only what their game requires.

### Engine Core and Runtime

YAGE’s **engine core** is intentionally minimal. Its primary responsibilities are:

* Initializing and orchestrating components.

* Managing the execution lifecycle (update loops, scheduling, event handling).

* Providing minimal abstractions for time, logging, and error management.

The runtime is **not a heavy framework** — instead, it is a **thin kernel** that coordinates components. By minimizing core responsibilities, YAGE maximizes flexibility, allowing projects to scale from small 2D prototypes to complex 3D worlds without excess runtime weight.

### Configuration System

The **Configuration System** implements the *Configurability* principle introduced in the Core Philosophy section. It provides a concrete mechanism for expressing and managing how engine components, assets, and runtime parameters are composed and connected.

YAGE uses a **configuration-driven assembly model**, inspired by how tools like Webpack bundle code. Developers declare which components to include and how they should interact, and YAGE builds a tailored engine accordingly.

Configuration can be expressed through:

* **Declarative project manifests** (Cargo integration + engine-specific metadata).
* **Programmatic configuration** (Rust code that composes traits and systems).
* **Automatic inference** (components activated by the presence of certain assets).

This approach allows for **smart defaults** while preserving full developer control. Like Webpack, YAGE prioritizes flexibility without sacrificing performance.

### Build-time Derivation from Assets

One of YAGE’s defining features is its **asset-driven build pipeline**. Instead of requiring manual engine setup, YAGE derives configuration from the project’s assets and code.

Examples:

* **Shaders:** automatically compiled and linked into the rendering pipeline.
* **Models and textures:** trigger setup of mesh loaders, GPU upload paths, and material systems.
* **Audio files:** configure playback systems, mixing, and streaming pipelines.
* **Entity definitions:** drive ECS schema generation at compile time.

Beyond static configuration, YAGE’s asset derivation process is **schema-aware**. Each recognized asset format—such as glTF, PNG, OGG, Rive JSON, or BehaviorTree JSON—is handled by a registered loader that translates declarative data into strongly typed ECS components. These loaders are pure, deterministic transformations that map existing open standards into engine-ready structures using `serde`-based deserialization and validated schemas.

Because this translation happens at build time or load time (depending on the asset), asset-defined logic incurs no additional runtime overhead compared to equivalent hardcoded Rust code. The result is a predictable, fully typed composition model where **assets define structure and intent**, and **systems interpret** those declarations.

For more dynamic behaviors, YAGE supports sandboxed module binding. Asset metadata may reference **WASM components** or **Lua scripts** that provide runtime behavior under strict capability scopes. The engine simply connects these declared modules to ECS events and traits; it does not reinterpret or extend their formats. This approach ensures that even dynamic behaviors remain asset-defined, portable, and testable, while the engine core remains minimal and deterministic.

By shifting complexity to the build process, YAGE ensures the runtime remains **lean, optimized, and deterministic**. This enables **reproducible builds** and aligns with modern DevOps practices (e.g., CI/CD integration, reproducible deployments).

### Lifecycle and Pipeline Management

YAGE’s architecture is designed not only for modularity of entities and assets, but also for dynamic adaptation across different stages of a game’s lifecycle. This requires a flexible system capable of managing multiple asset sets, pipelines, and runtime transitions.

#### Key architecture elements

* **Lifecycle-Aware Pipelines**
  * Each game may define multiple asset pipelines (e.g., tutorial, midgame, endgame, live event).
  * Pipelines can specify variations in asset fidelity, features, or systems.
  * The system allows branching or merging pipelines as the game progresses.

* **Runtime Asset Manager**
  * Core service that supports loading, unloading, and substituting assets dynamically at runtime.
  * Assets can be tagged with lifecycle metadata (e.g., “early-game,” “post-expansion,” “seasonal-event”).
  * Ensures that inactive assets are efficiently removed to reclaim memory.

* **State-Driven Transitions**
  * Lifecycle events exist for game state triggers (e.g., completion of tutorial, start of seasonal event, chapter progression).
  * Developers can attach lifecycle rules to these transitions, specifying which pipelines or asset sets should activate.

* **Parallel Pipelines**
  * In complex games, multiple pipelines may run concurrently (e.g., core game pipeline + live event pipeline).
  * Architecture ensures isolation between pipelines while still allowing shared resource access.

* **Lifecycle-Oriented Extensibility**
  * External modules can register new lifecycle events or pipelines.
  * Supports third-party or custom lifecycles (e.g., roguelike resets, episodic content delivery).

#### Example Diagram [TBD: example diagram]

* **Lifecycle State Machine** showing transitions between lifecycle stages.
* **Asset Pipeline Overlay** showing how assets are swapped or upgraded across stages.
